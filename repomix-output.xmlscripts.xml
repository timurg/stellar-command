<file path="Assets/Scripts/Core/Entity.cs">
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public abstract class Entity : MonoBehaviour
{
    [SerializeField] protected float mass = 1f; // Масса (для Rigidbody2D)
    [SerializeField] protected float maxHealth = 1000f; // Максимальное здоровье
    protected float Health { get; set; }
    protected Vector2 Direction { get; set; } // Направление движения (нормализованный вектор)
    protected Rigidbody2D Rigidbody { get; private set; }
    protected bool Alive { get; private set; } = true; // Остаётся private set
    protected virtual void Awake()
    {
        Rigidbody = GetComponent<Rigidbody2D>();
        if (Rigidbody == null)
        {
            Debug.LogError("Rigidbody2D not found on Entity! Please add it.");
            return;
        }
        Rigidbody.mass = mass;
        Health = maxHealth;
    }
    protected virtual void FixedUpdate()
    {
        if (!Alive) return;
        if (Direction.magnitude > 0) // Движение по Direction, если не нулевое
        {
            Rigidbody.linearVelocity = Direction.normalized * Rigidbody.linearVelocity.magnitude; // Поддерживаем скорость, меняем направление
        }
    }
    protected virtual void Update()
    {
        if (!Alive) return;
    }
    public virtual void TakeDamage(float damage, bool ignoreShields = false)
    {
        Health -= damage;
        if (Health <= 0 && Alive)
        {
            SetAlive(false); // Используем метод для изменения состояния
            OnDeath();
        }
    }
    protected virtual void OnDeath()
    {
        Destroy(gameObject);
    }
    // Защищённый метод для установки Alive
    protected virtual void SetAlive(bool state)
    {
        Alive = state;
    }
    public bool IsAlive() => Alive; // Публичный метод для проверки
}
</file>
<file path="Assets/Scripts/Core/Ship.cs">
using UnityEngine;
using System.Collections.Generic;
using System;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
public abstract class Ship : Entity
{
    [SerializeField] protected float shields = 500f; // Щиты
    [SerializeField] protected float maxShields = 500f; // Максимум щитов
    [SerializeField] protected float acceleration = 200f; // Ускорение
    [SerializeField] protected float maxSpeed = 100f; // Максимальная скорость
    [SerializeField] protected bool rotateToDirection = true; // Флаг для ротации
    protected List<Weapon> weapons = new List<Weapon>(); // Набор оружия
    protected Entity target; // Цель
    public enum ShipState
    {
        HANGAR,    // В ангаре (refuel/repair)
        PATROL,    // Патруль вокруг Carrier
        ATTACK,    // Атака врага
        RETURN,    // Возврат к Carrier
        DAMAGED    // Повреждён, в ангаре на ремонт
    }
    private ShipState state = ShipState.HANGAR; // Приватное поле
    protected override void Awake()
    {
        base.Awake();
        IgnoreShipCollisions(); // Настройка игнорирования коллизий между кораблями
        // Инициализация оружия (добавь в Inspector или коде)
    }
    protected void Start()
    {
        IgnoreShipCollisions(); // Настройка игнорирования коллизий между кораблями
    }
    protected override void Update()
    {
        base.Update();
        if (!IsAlive()) return;
        if (shields < maxShields) shields += Time.deltaTime * 10f; // Пример регена щитов
        ShootAtTarget(); // Вызов общего метода стрельбы
        CalculateDirection(); // Вызов абстрактного метода для выбора направления
    }
    // Абстрактный метод для расчёта направления движения (потомки переопределяют)
    protected abstract void CalculateDirection();
    // Метод для движения с ротацией (использует Direction из Entity)
    protected void Move()
    {
        if (Direction.magnitude > 0) // Проверяем, есть ли направление
        {
            Vector2 force = Direction.normalized * acceleration;
            Rigidbody.AddForce(force * Time.fixedDeltaTime, ForceMode2D.Impulse); // Используем fixedDeltaTime
            if (Rigidbody.linearVelocity.magnitude > maxSpeed)
            {
                Rigidbody.linearVelocity = Rigidbody.linearVelocity.normalized * maxSpeed;
            }
            // Ротация в сторону движения, если включена
            if (rotateToDirection && Rigidbody.linearVelocity.magnitude > 0.1f)
            {
                float targetAngle = Mathf.Atan2(Rigidbody.linearVelocity.y, Rigidbody.linearVelocity.x) * Mathf.Rad2Deg - 90f; // -90f для носа вверх
                transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.Euler(0, 0, targetAngle), 0.2f);
            }
        }
    }
    public void SetTarget(Entity newTarget)
    {
        target = newTarget;
    }
    // Общий метод стрельбы
    protected virtual void ShootAtTarget()
    {
        if (target == null) target = SelectTarget(); // Выбираем цель, если нет
        if (target != null && IsAlive())
        {
            foreach (var weapon in weapons)
            {
                if (weapon != null)
                {
                    weapon.SetTarget(target.transform.position); // Устанавливаем цель
                    weapon.ShootIfReady(); // Активируем стрельбу
                }
            }
        }
    }
    // Абстрактный метод для выбора цели
    protected abstract Entity SelectTarget();
    // Геттер и контролируемый сеттер для State
    public ShipState GetState() => state;
    protected virtual void SetState(ShipState newState)
    {
        state = newState;
        // Дополнительная логика при смене состояния
        switch (newState)
        {
            case ShipState.DAMAGED:
                if (shields <= 0) SetAlive(false); // Пример: смерть при нулевых щитах
                break;
        }
    }
    // Метод для игнорирования коллизий между кораблями
    private void IgnoreShipCollisions()
    {
        Ship[] ships = FindObjectsByType<Ship>(FindObjectsInactive.Exclude, FindObjectsSortMode.None);
        Debug.Log($"Found {ships.Length} ships for collision ignoring.");
        foreach (var otherShip in ships)
        {
            if (otherShip != this && otherShip.GetComponent<Collider2D>() != null)
            {
                Physics2D.IgnoreCollision(GetComponent<Collider2D>(), otherShip.GetComponent<Collider2D>(), true);
                Debug.Log($"Ignoring collision between {this.name} and {otherShip.name}");
            }
        }
    }
}
</file>
<file path="Assets/Scripts/Core/Weapon.cs">
using UnityEngine;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public abstract class Weapon : Entity
{
    [SerializeField] protected float damage = 20f; // Дамаг
    [SerializeField] protected bool ignoresShields = false; // Игнорирует щиты (для Rocket)
    [SerializeField] protected float speed = 300f; // Скорость (для PhotonBall/Rocket)
    [SerializeField] protected float shootCooldown = 1f; // Кулдаун стрельбы для оружия
    protected float shootTimer = 0f; // Таймер для управления стрельбой
    protected Rigidbody2D rb; // Для физики движения
    protected override void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        if (rb == null)
        {
            Debug.LogError("Rigidbody2D not found on Weapon! Please add it.");
            return;
        }
        rb.bodyType = RigidbodyType2D.Kinematic; // Для управляемого движения
        rb.gravityScale = 0;
        var collider = GetComponent<Collider2D>();
        if (collider != null)
        {
            collider.isTrigger = true; // Для OnTriggerEnter2D вместо столкновений
        }
    }
    protected override void Update()
    {
        // Обновляем таймер стрельбы
        if (shootTimer > 0) shootTimer -= Time.deltaTime;
        // Базовое движение (переопределяется в наследниках)
        transform.position += transform.right * speed * Time.deltaTime;
    }
    protected virtual void OnTriggerEnter2D(Collider2D other)
    {
        Entity entity = other.GetComponent<Entity>();
        if (entity != null)
        {
            entity.TakeDamage(damage, ignoresShields);
            // Взрыв: Instantiate(explosionPrefab, transform.position, Quaternion.identity);
            Destroy(gameObject); // Уничтожить снаряд
        }
    }
    public float Damage => damage;
    public bool IgnoresShields => ignoresShields;
    public abstract bool IsGuided(); // Для Rocket
    public abstract void SetTarget(Vector2 targetPos); // Для guided
    // Публичный метод для активации стрельбы
    public virtual void ShootIfReady()
    {
        if (shootTimer <= 0)
        {
            // Логика спавна снаряда (реализуется в наследниках)
            shootTimer = shootCooldown;
        }
    }
}
</file>
<file path="Assets/Scripts/Entities/Carrier.cs">
using UnityEngine;
using UnityEngine.InputSystem;
using System.Collections.Generic;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(PlayerInput))]
[RequireComponent(typeof(SpriteRenderer))]
public class Carrier : Ship
{
    [SerializeField] private int maxInterceptors = 5; // Максимум истребителей
    private List<Interceptor> hangar = new List<Interceptor>(); // Ангар для истребителей
    private InputAction moveHorizontal;
    private InputAction moveVertical;
    private InputAction clickAction;
    private InputAction clickPosition;
    private Vector2 smoothInput;
    protected override void Awake()
    {
        base.Awake();
        var playerInput = GetComponent<PlayerInput>();
        if (playerInput == null)
        {
            Debug.LogError("PlayerInput component not found on Carrier! Please add it.");
            return;
        }
        moveHorizontal = playerInput.actions["MoveHorizontal"];
        moveVertical = playerInput.actions["MoveVertical"];
        clickAction = playerInput.actions["Click"];
        clickPosition = playerInput.actions["ClickPosition"];
    }
    private void FixedUpdate()
    {
        HandleMovement(Time.fixedDeltaTime);
    }
    private void HandleMovement(float deltaTime)
    {
        float rawX = moveHorizontal.ReadValue<float>();
        float rawY = moveVertical.ReadValue<float>();
        smoothInput = Vector2.Lerp(smoothInput, new Vector2(rawX, rawY), 0.1f);
        Vector2 direction = smoothInput.normalized; // Преобразуем в направление
        if (clickAction.WasPerformedThisFrame())
        {
            Vector2 mousePos = clickPosition.ReadValue<Vector2>();
            mousePos = Camera.main.ScreenToWorldPoint(mousePos);
            direction = (mousePos - (Vector2)transform.position).normalized;
            smoothInput = direction; // Сброс сглаживания при клике
        }
        Move(direction); // Вызываем Move с направлением
    }
    protected override Entity SelectTarget()
    {
        return null; // Carrier не выбирает цель по умолчанию
    }
    protected override void SetState(ShipState newState)
    {
        base.SetState(newState);
        // Дополнительная логика для Carrier
    }
    public void AddInterceptor(Interceptor interceptor)
    {
        if (hangar.Count < maxInterceptors) hangar.Add(interceptor);
    }
}
</file>
<file path="Assets/Scripts/Entities/Enemy.cs">
using UnityEngine;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public class Enemy : Ship
{
    [SerializeField] private float attackDistance = 3f; // Уменьшенная дистанция атаки
    [SerializeField] private float spawnEdgeOffset = 10f; // Смещение от краёв экрана при спавне
    [SerializeField] private float orbitRadiusMin = 2f; // Минимальный радиус орбиты
    [SerializeField] private float orbitRadiusMax = 5f; // Максимальный радиус орбиты
    [SerializeField] private float orbitAngularSpeed = Mathf.PI / 8f; // Угловая скорость орбиты
    [SerializeField] private float courseCorrectionInterval = 2f; // Интервал корректировки курса
    private float orbitRadius; // Случайный радиус для каждого Enemy
    private float orbitAngle = 0f; // Угол орбиты
    private Vector2 smoothedOrbitDirection = Vector2.zero; // Буфер для сглаживания направления
    private float courseCorrectionTimer = 0f; // Таймер для корректировки
    private Vector2[] orbitPathPoints; // Ключевые точки траектории (сплайн)
    private int currentPointIndex = 0; // Индекс текущей точки траектории
    protected override void Awake()
    {
        base.Awake();
        target = FindClosestShip(); // Инициализация: Находим ближайший Ship
        if (target == null)
        {
            Debug.LogError("Enemy: No Ship found in scene!");
        }
        orbitRadius = Random.Range(orbitRadiusMin, orbitRadiusMax); // Случайный радиус орбиты
        courseCorrectionTimer = courseCorrectionInterval; // Начальное значение таймера
        orbitPathPoints = new Vector2[0]; // Инициализация пустого массива
    }
    protected override void Update()
    {
        base.Update();
        if (target == null || !IsAlive()) return;
        Collider2D targetCollider = target.GetComponent<Collider2D>();
        Vector2 closestPoint = targetCollider.ClosestPoint(transform.position); // Ближайшая точка на коллайдере цели
        Vector2 direction = (closestPoint - (Vector2)transform.position).normalized;
        float distanceToTarget = Vector2.Distance((Vector2)transform.position, closestPoint); // Расстояние до ближайшей точки
        Debug.Log($"Distance to Target Closest Point: {distanceToTarget}, Direction: {direction}");
        if (distanceToTarget > attackDistance)
        {
            Move(direction); // Лететь к цели
        }
        else
        {
            OrbitAroundTarget(distanceToTarget, closestPoint); // Орбитальное движение вокруг цели
            ShootAtTarget(); // Стрельба по цели
        }
    }
    protected override void OnDeath()
    {
        base.OnDeath();
        EnemyPoolManager.Instance.ReturnEnemy(this); // Возвращаем в пул вместо Destroy
    }
    protected override Entity SelectTarget()
    {
        return target; // Возвращаем текущую цель
    }
    protected override void SetState(ShipState newState)
    {
        base.SetState(newState);
        // Дополнительная логика для Enemy
    }
    public void SpawnAtEdge()
    {
        Vector2 screenBounds = Camera.main.ScreenToWorldPoint(new Vector2(Screen.width, Screen.height));
        int edge = Random.Range(0, 4);
        Vector2 spawnPos = Vector2.zero;
        switch (edge)
        {
            case 0: spawnPos = new Vector2(-screenBounds.x - spawnEdgeOffset, Random.Range(-screenBounds.y, screenBounds.y)); break;
            case 1: spawnPos = new Vector2(screenBounds.x + spawnEdgeOffset, Random.Range(-screenBounds.y, screenBounds.y)); break;
            case 2: spawnPos = new Vector2(Random.Range(-screenBounds.x, screenBounds.x), screenBounds.y + spawnEdgeOffset); break;
            case 3: spawnPos = new Vector2(Random.Range(-screenBounds.x, screenBounds.x), -screenBounds.y - spawnEdgeOffset); break;
        }
        transform.position = spawnPos;
        SetAlive(true); // Восстанавливаем состояние
        Health = maxHealth; // Восстанавливаем здоровье
        shields = maxShields; // Восстанавливаем щиты
        SetState(ShipState.PATROL); // Устанавливаем начальное состояние
        orbitAngle = Random.Range(0f, 2f * Mathf.PI); // Случайный стартовый угол орбиты
        courseCorrectionTimer = courseCorrectionInterval; // Сбрасываем таймер при спавне
    }
    private void OrbitAroundTarget(float distanceToTarget, Vector2 closestPoint)
    {
        if (distanceToTarget <= attackDistance) // Используем attackDistance как границу орбиты
        {
            courseCorrectionTimer -= Time.deltaTime; // Уменьшаем таймер
            if (courseCorrectionTimer <= 0f)
            {
                // Корректировка курса каждые 0.7 секунды
                orbitAngle += orbitAngularSpeed * Time.deltaTime; // Обновляем угол
                Vector2 offset = new Vector2(Mathf.Cos(orbitAngle), Mathf.Sin(orbitAngle)) * orbitRadius;
                Vector2 desiredPosition = (Vector2)target.transform.position + offset;
                Vector2 rawOrbitDirection = (desiredPosition - (Vector2)transform.position).normalized;
                smoothedOrbitDirection = Vector2.Lerp(smoothedOrbitDirection, rawOrbitDirection, 0.1f); // Сглаживание
                courseCorrectionTimer = courseCorrectionInterval; // Сбрасываем таймер
            }
            Move(smoothedOrbitDirection); // Двигаемся по сглаженной орбите
        }
        else
        {
            Move((closestPoint - (Vector2)transform.position).normalized); // Подходим ближе
        }
    }
    // Метод для поиска ближайшего Ship как цели
    private Ship FindClosestShip()
    {
        Ship[] ships = FindObjectsOfType<Carrier>();
        Ship closest = null;
        float closestDistance = Mathf.Infinity;
        foreach (var ship in ships)
        {
            if (ship.IsAlive())
            {
                float distance = Vector2.Distance(transform.position, ship.transform.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    closest = ship;
                }
            }
        }
        return closest;
    }
}
</file>
<file path="Assets/Scripts/Entities/Interceptor.cs">
using UnityEngine;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public class Interceptor : Ship
{
    [SerializeField] private float patrolRadius = 150f; // Радиус патруля
    [SerializeField] private float attackRadius = 75f; // Радиус атаки
    private Carrier carrier; // Ссылка на Carrier
    protected override void Awake()
    {
        base.Awake();
        carrier = FindFirstObjectByType<Carrier>();
    }
    protected override void Update()
    {
        base.Update();
        if (carrier == null || !IsAlive()) return;
        Entity newTarget = SelectTarget();
        if (newTarget != null && GetState() == ShipState.HANGAR)
        {
            SetState(ShipState.PATROL); // Вылет при обнаружении цели
        }
    }
    protected override Entity SelectTarget()
    {
        // Выбираем ближайшего врага
        Enemy[] enemies = FindObjectsOfType<Enemy>();
        Entity closestTarget = null;
        float closestDistance = Mathf.Infinity;
        foreach (var enemy in enemies)
        {
            if (enemy.IsAlive())
            {
                float distance = Vector2.Distance(transform.position, enemy.transform.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    closestTarget = enemy;
                }
            }
        }
        return closestTarget;
    }
    protected override void SetState(ShipState newState)
    {
        base.SetState(newState);
        switch (newState)
        {
            case ShipState.PATROL:
                transform.position = carrier.transform.position; // Возвращение к Carrier
                break;
            case ShipState.RETURN:
                // Дополнительная логика возврата
                break;
        }
    }
}
</file>
</files><file path="Assets/Scripts/Core/Entity.cs">
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public abstract class Entity : MonoBehaviour
{
    [SerializeField] protected float mass = 1f; // Масса (для Rigidbody2D)
    [SerializeField] protected float maxHealth = 1000f; // Максимальное здоровье
    protected float Health { get; set; }
    protected Vector2 Direction { get; set; } // Направление движения (нормализованный вектор)
    protected Rigidbody2D Rigidbody { get; private set; }
    protected bool Alive { get; private set; } = true; // Остаётся private set
    protected virtual void Awake()
    {
        Rigidbody = GetComponent<Rigidbody2D>();
        if (Rigidbody == null)
        {
            Debug.LogError("Rigidbody2D not found on Entity! Please add it.");
            return;
        }
        Rigidbody.mass = mass;
        Health = maxHealth;
    }
    protected virtual void FixedUpdate()
    {
        if (!Alive) return;
        if (Direction.magnitude > 0) // Движение по Direction, если не нулевое
        {
            Vector2 force = Direction.normalized * acceleration; // Используем acceleration из Ship
            Rigidbody.AddForce(force * Time.fixedDeltaTime, ForceMode2D.Impulse);
            if (Rigidbody.linearVelocity.magnitude > maxSpeed)
            {
                Rigidbody.linearVelocity = Rigidbody.linearVelocity.normalized * maxSpeed;
            }
        }
    }
    protected virtual void Update()
    {
        if (!Alive) return;
    }
    public virtual void TakeDamage(float damage, bool ignoreShields = false)
    {
        Health -= damage;
        if (Health <= 0 && Alive)
        {
            SetAlive(false); // Используем метод для изменения состояния
            OnDeath();
        }
    }
    protected virtual void OnDeath()
    {
        Destroy(gameObject);
    }
    // Защищённый метод для установки Alive
    protected virtual void SetAlive(bool state)
    {
        Alive = state;
    }
    public bool IsAlive() => Alive; // Публичный метод для проверки
}
</file>
<file path="Assets/Scripts/Core/Ship.cs">
using UnityEngine;
using System.Collections.Generic;
using System;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
public abstract class Ship : Entity
{
    [SerializeField] protected float shields = 500f; // Щиты
    [SerializeField] protected float maxShields = 500f; // Максимум щитов
    [SerializeField] protected float acceleration = 200f; // Ускорение
    [SerializeField] protected float maxSpeed = 100f; // Максимальная скорость
    [SerializeField] protected bool rotateToDirection = true; // Флаг для ротации
    protected List<Weapon> weapons = new List<Weapon>(); // Набор оружия
    protected Entity target; // Цель
    public enum ShipState
    {
        HANGAR,    // В ангаре (refuel/repair)
        PATROL,    // Патруль вокруг Carrier
        ATTACK,    // Атака врага
        RETURN,    // Возврат к Carrier
        DAMAGED    // Повреждён, в ангаре на ремонт
    }
    private ShipState state = ShipState.HANGAR; // Приватное поле
    protected override void Awake()
    {
        base.Awake();
        IgnoreShipCollisions(); // Настройка игнорирования коллизий между кораблями
        // Инициализация оружия (добавь в Inspector или коде)
    }
    protected void Start()
    {
        IgnoreShipCollisions(); // Настройка игнорирования коллизий между кораблями
    }
    protected override void Update()
    {
        base.Update();
        if (!IsAlive()) return;
        if (shields < maxShields) shields += Time.deltaTime * 10f; // Пример регена щитов
        ShootAtTarget(); // Вызов общего метода стрельбы
        UpdateDirection(); // Вызов абстрактного метода для обновления направления
    }
    // Абстрактный метод для обновления направления (потомки переопределяют)
    protected abstract void UpdateDirection();
    // Метод для игнорирования коллизий между кораблями
    private void IgnoreShipCollisions()
    {
        Ship[] ships = FindObjectsByType<Ship>(FindObjectsInactive.Exclude, FindObjectsSortMode.None);
        Debug.LogError($"Found {ships.Length} ships for collision ignoring.");
        foreach (var otherShip in ships)
        {
            if (otherShip != this && otherShip.GetComponent<Collider2D>() != null)
            {
                Physics2D.IgnoreCollision(GetComponent<Collider2D>(), otherShip.GetComponent<Collider2D>(), true);
                Debug.LogError("collision ignored between " + this.name + " and " + otherShip.name);
            }
        }
    }
    public void SetTarget(Entity newTarget)
    {
        target = newTarget;
    }
    // Общий метод стрельбы
    protected virtual void ShootAtTarget()
    {
        if (target == null) target = SelectTarget(); // Выбираем цель, если нет
        if (target != null && IsAlive())
        {
            foreach (var weapon in weapons)
            {
                if (weapon != null)
                {
                    weapon.SetTarget(target.transform.position); // Устанавливаем цель
                    weapon.ShootIfReady(); // Активируем стрельбу
                }
            }
        }
    }
    // Абстрактный метод для выбора цели
    protected abstract Entity SelectTarget();
    // Геттер и контролируемый сеттер для State
    public ShipState GetState() => state;
    protected virtual void SetState(ShipState newState)
    {
        state = newState;
        // Дополнительная логика при смене состояния
        switch (newState)
        {
            case ShipState.DAMAGED:
                if (shields <= 0) SetAlive(false); // Пример: смерть при нулевых щитах
                break;
        }
    }
}
</file>
<file path="Assets/Scripts/Core/Weapon.cs">
using UnityEngine;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public abstract class Weapon : Entity
{
    [SerializeField] protected float damage = 20f; // Дамаг
    [SerializeField] protected bool ignoresShields = false; // Игнорирует щиты (для Rocket)
    [SerializeField] protected float speed = 300f; // Скорость (для PhotonBall/Rocket)
    [SerializeField] protected float shootCooldown = 1f; // Кулдаун стрельбы для оружия
    protected float shootTimer = 0f; // Таймер для управления стрельбы
    protected Rigidbody2D rb; // Для физики движения
    protected override void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        if (rb == null)
        {
            Debug.LogError("Rigidbody2D not found on Weapon! Please add it.");
            return;
        }
        rb.bodyType = RigidbodyType2D.Kinematic; // Для управляемого движения
        rb.gravityScale = 0;
        var collider = GetComponent<Collider2D>();
        if (collider != null)
        {
            collider.isTrigger = true; // Для OnTriggerEnter2D вместо столкновений
        }
    }
    protected override void Update()
    {
        // Обновляем таймер стрельбы
        if (shootTimer > 0) shootTimer -= Time.deltaTime;
        // Базовое движение (переопределяется в наследниках)
        transform.position += transform.right * speed * Time.deltaTime;
    }
    protected virtual void OnTriggerEnter2D(Collider2D other)
    {
        Entity entity = other.GetComponent<Entity>();
        if (entity != null)
        {
            entity.TakeDamage(damage, ignoresShields);
            // Взрыв: Instantiate(explosionPrefab, transform.position, Quaternion.identity);
            Destroy(gameObject); // Уничтожить снаряд
        }
    }
    public float Damage => damage;
    public bool IgnoresShields => ignoresShields;
    public abstract bool IsGuided(); // Для Rocket
    public abstract void SetTarget(Vector2 targetPos); // Для guided
    // Публичный метод для активации стрельбы
    public virtual void ShootIfReady()
    {
        if (shootTimer <= 0)
        {
            // Логика спавна снаряда (реализуется в наследниках)
            shootTimer = shootCooldown;
        }
    }
}
</file>
<file path="Assets/Scripts/Entities/Carrier.cs">
using UnityEngine;
using UnityEngine.InputSystem;
using System.Collections.Generic;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(PlayerInput))]
[RequireComponent(typeof(SpriteRenderer))]
public class Carrier : Ship
{
    [SerializeField] private int maxInterceptors = 5; // Максимум истребителей
    private List<Interceptor> hangar = new List<Interceptor>(); // Ангар для истребителей
    private InputAction moveHorizontal;
    private InputAction moveVertical;
    private InputAction clickAction;
    private InputAction clickPosition;
    private Vector2 smoothInput;
    protected override void Awake()
    {
        base.Awake();
        var playerInput = GetComponent<PlayerInput>();
        if (playerInput == null)
        {
            Debug.LogError("PlayerInput component not found on Carrier! Please add it.");
            return;
        }
        moveHorizontal = playerInput.actions["MoveHorizontal"];
        moveVertical = playerInput.actions["MoveVertical"];
        clickAction = playerInput.actions["Click"];
        clickPosition = playerInput.actions["ClickPosition"];
    }
    private void FixedUpdate()
    {
        HandleMovement(Time.fixedDeltaTime);
    }
    private void HandleMovement(float deltaTime)
    {
        float rawX = moveHorizontal.ReadValue<float>();
        float rawY = moveVertical.ReadValue<float>();
        smoothInput = Vector2.Lerp(smoothInput, new Vector2(rawX, rawY), 0.1f);
        Vector2 direction = smoothInput.normalized; // Преобразуем в направление
        if (clickAction.WasPerformedThisFrame())
        {
            Vector2 mousePos = clickPosition.ReadValue<Vector2>();
            mousePos = Camera.main.ScreenToWorldPoint(mousePos);
            direction = (mousePos - (Vector2)transform.position).normalized;
            smoothInput = direction; // Сброс сглаживания при клике
        }
        Move(direction); // Вызываем Move с направлением
    }
    protected override Entity SelectTarget()
    {
        return null; // Carrier не выбирает цель по умолчанию
    }
    protected override void SetState(ShipState newState)
    {
        base.SetState(newState);
        // Дополнительная логика для Carrier
    }
    public void AddInterceptor(Interceptor interceptor)
    {
        if (hangar.Count < maxInterceptors) hangar.Add(interceptor);
    }
}
</file>
<file path="Assets/Scripts/Entities/Enemy.cs">
using UnityEngine;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public class Enemy : Ship
{
    [SerializeField] private float attackDistance = 3f; // Уменьшенная дистанция атаки
    [SerializeField] private float spawnEdgeOffset = 10f; // Смещение от краёв экрана при спавне
    [SerializeField] private float orbitRadiusMin = 2f; // Минимальный радиус орбиты
    [SerializeField] private float orbitRadiusMax = 5f; // Максимальный радиус орбиты
    [SerializeField] private float orbitAngularSpeed = Mathf.PI / 8f; // Угловая скорость орбиты
    [SerializeField] private float courseCorrectionInterval = 2f; // Интервал корректировки курса
    private float orbitRadius; // Случайный радиус для каждого Enemy
    private float orbitAngle = 0f; // Угол орбиты
    private Vector2 smoothedOrbitDirection = Vector2.zero; // Буфер для сглаживания направления
    private float courseCorrectionTimer = 0f; // Таймер для корректировки
    private Vector2[] orbitPathPoints; // Ключевые точки траектории (сплайн)
    private int currentPointIndex = 0; // Индекс текущей точки траектории
    protected override void Awake()
    {
        base.Awake();
        target = FindClosestShip(); // Инициализация: Находим ближайший Ship
        if (target == null)
        {
            Debug.LogError("Enemy: No Ship found in scene!");
        }
        orbitRadius = Random.Range(orbitRadiusMin, orbitRadiusMax); // Случайный радиус орбиты
        courseCorrectionTimer = courseCorrectionInterval; // Начальное значение таймера
        orbitPathPoints = new Vector2[0]; // Инициализация пустого массива
    }
    protected override void Update()
    {
        base.Update();
        if (target == null || !IsAlive()) return;
        Collider2D targetCollider = target.GetComponent<Collider2D>();
        Vector2 closestPoint = targetCollider.ClosestPoint(transform.position); // Ближайшая точка на коллайдере цели
        Vector2 direction = (closestPoint - (Vector2)transform.position).normalized;
        float distanceToTarget = Vector2.Distance((Vector2)transform.position, closestPoint); // Расстояние до ближайшей точки
        Debug.Log($"Distance to Target Closest Point: {distanceToTarget}, Direction: {direction}");
        if (distanceToTarget > attackDistance)
        {
            Move(direction); // Лететь к цели
        }
        else
        {
            OrbitAroundTarget(distanceToTarget, closestPoint); // Орбитальное движение вокруг цели
            ShootAtTarget(); // Стрельба по цели
        }
    }
    protected override void OnDeath()
    {
        base.OnDeath();
        EnemyPoolManager.Instance.ReturnEnemy(this); // Возвращаем в пул вместо Destroy
    }
    protected override Entity SelectTarget()
    {
        return target; // Возвращаем текущую цель
    }
    protected override void SetState(ShipState newState)
    {
        base.SetState(newState);
        // Дополнительная логика для Enemy
    }
    public void SpawnAtEdge()
    {
        Vector2 screenBounds = Camera.main.ScreenToWorldPoint(new Vector2(Screen.width, Screen.height));
        int edge = Random.Range(0, 4);
        Vector2 spawnPos = Vector2.zero;
        switch (edge)
        {
            case 0: spawnPos = new Vector2(-screenBounds.x - spawnEdgeOffset, Random.Range(-screenBounds.y, screenBounds.y)); break;
            case 1: spawnPos = new Vector2(screenBounds.x + spawnEdgeOffset, Random.Range(-screenBounds.y, screenBounds.y)); break;
            case 2: spawnPos = new Vector2(Random.Range(-screenBounds.x, screenBounds.x), screenBounds.y + spawnEdgeOffset); break;
            case 3: spawnPos = new Vector2(Random.Range(-screenBounds.x, screenBounds.x), -screenBounds.y - spawnEdgeOffset); break;
        }
        transform.position = spawnPos;
        SetAlive(true); // Восстанавливаем состояние
        Health = maxHealth; // Восстанавливаем здоровье
        shields = maxShields; // Восстанавливаем щиты
        SetState(ShipState.PATROL); // Устанавливаем начальное состояние
        orbitAngle = Random.Range(0f, 2f * Mathf.PI); // Случайный стартовый угол орбиты
        courseCorrectionTimer = courseCorrectionInterval; // Сбрасываем таймер при спавне
    }
    private void OrbitAroundTarget(float distanceToTarget, Vector2 closestPoint)
    {
        if (distanceToTarget <= attackDistance) // Используем attackDistance как границу орбиты
        {
            courseCorrectionTimer -= Time.deltaTime; // Уменьшаем таймер
            if (courseCorrectionTimer <= 0f)
            {
                // Корректировка курса каждые 0.7 секунды
                orbitAngle += orbitAngularSpeed * Time.deltaTime; // Обновляем угол
                Vector2 offset = new Vector2(Mathf.Cos(orbitAngle), Mathf.Sin(orbitAngle)) * orbitRadius;
                Vector2 desiredPosition = (Vector2)target.transform.position + offset;
                Vector2 rawOrbitDirection = (desiredPosition - (Vector2)transform.position).normalized;
                smoothedOrbitDirection = Vector2.Lerp(smoothedOrbitDirection, rawOrbitDirection, 0.1f); // Сглаживание
                courseCorrectionTimer = courseCorrectionInterval; // Сбрасываем таймер
            }
            Move(smoothedOrbitDirection); // Двигаемся по сглаженной орбите
        }
        else
        {
            Move((closestPoint - (Vector2)transform.position).normalized); // Подходим ближе
        }
    }
    // Метод для поиска ближайшего Ship как цели
    private Ship FindClosestShip()
    {
        Ship[] ships = FindObjectsOfType<Carrier>();
        Ship closest = null;
        float closestDistance = Mathf.Infinity;
        foreach (var ship in ships)
        {
            if (ship.IsAlive())
            {
                float distance = Vector2.Distance(transform.position, ship.transform.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    closest = ship;
                }
            }
        }
        return closest;
    }
}
</file>
<file path="Assets/Scripts/Entities/Interceptor.cs">
using UnityEngine;
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(BoxCollider2D))]
[RequireComponent(typeof(SpriteRenderer))]
public class Interceptor : Ship
{
    [SerializeField] private float patrolRadius = 150f; // Радиус патруля
    [SerializeField] private float attackRadius = 75f; // Радиус атаки
    private Carrier carrier; // Ссылка на Carrier
    protected override void Awake()
    {
        base.Awake();
        carrier = FindFirstObjectByType<Carrier>();
    }
    protected override void Update()
    {
        base.Update();
        if (carrier == null || !IsAlive()) return;
        Entity newTarget = SelectTarget();
        if (newTarget != null && GetState() == ShipState.HANGAR)
        {
            SetState(ShipState.PATROL); // Вылет при обнаружении цели
        }
    }
    protected override Entity SelectTarget()
    {
        // Выбираем ближайшего врага
        Enemy[] enemies = FindObjectsOfType<Enemy>();
        Entity closestTarget = null;
        float closestDistance = Mathf.Infinity;
        foreach (var enemy in enemies)
        {
            if (enemy.IsAlive())
            {
                float distance = Vector2.Distance(transform.position, enemy.transform.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    closestTarget = enemy;
                }
            }
        }
        return closestTarget;
    }
    protected override void SetState(ShipState newState)
    {
        base.SetState(newState);
        switch (newState)
        {
            case ShipState.PATROL:
                transform.position = carrier.transform.position; // Возвращение к Carrier
                break;
            case ShipState.RETURN:
                // Дополнительная логика возврата
                break;
        }
    }
}
</file>
</files>